{ config, pkgs, lib, nclib, ... } @ args:

with lib;

let
  cfg = config.nixcloud.reverse-proxy;
  stateDir = "/var/lib/nixcloud/reverse-proxy";
  user = "reverse-proxy";
  group = "reverse-proxy";
  mkBasicAuth = authDef: let
    htpasswdFile = pkgs.writeText "basicAuth.htpasswd" (
      concatStringsSep "\n" (mapAttrsToList (user: password: ''
        ${user}:{PLAIN}${password}
      '') authDef)
    );
  in ''
    auth_basic secured;
    auth_basic_user_file ${htpasswdFile};
  '';

in

{
  options = {
    nixcloud.reverse-proxy = {
      enable = mkEnableOption "reverse-proxy";
      httpPort = mkOption {
        type = types.int;
        default = 80;
        description = ''Port where the reverse proxy listens for incoming http requests. Note: This port is added to `networking.allowedTCPPorts`.'';
      };
      httpsPort = mkOption {
        type = types.int;
        default = 443;
        description = ''Port where the reverse proxy listens for incoming https requests. Note: This port is added to  `networking.allowedTCPPorts`'';
      };
      extendEtcHosts = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Write all configured domains into /etc/hosts using networking.extraHosts with ::1 and 127.0.0.1 as host ip. This helps with testing webservices and isn't required in production if DNS was setup correctly and has already propagated.
        ''; # '
      };
      extraConfig = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Extend the nginx configuration of the generated nixcloud.reverse-proxy
          configuration file.
        '';
        example = ''
          server {
            listen 80;
            listen [::]:80;
            server_name test.t;
            location /blog {
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          }
        '';
      };
      configFile = mkOption {
        type = types.nullOr types.path;
        default = null;
        description = ''
          The path to a configuration which can be used instead the generated one. If the `configFile` option is used most other options are completely ignored.
          This option exists because on nixcloud.io we need to generate the configuration file externally since we can't run `nixos-rebuild switch`.
        ''; #'
      };
      extraMappings = mkOption {
        type = types.listOf (types.submodule (import ./options.nix));
        default = [];
        description = ''
          Can be used to append proxy-mappings, created manually, for services not supporting `proxyOptions` in `nixcloud` namespace.
        '';
        example = ''
          [{
            port   = 3333;
            path   = "/tour";
            domain = "nixcloud.io";
            ip = "127.0.0.1";
          }];
        '';
      };
    };
  };

  config = let
    generateNginxConfigFile = allProxyOptions: allNCWDomains: pkgs.writeText "nginx-reverse-proxy.conf" ''
      # this file is auto-generated by nixcloud.reverse-proxy
      # https://github.com/nixcloud/nixcloud-webservices/blob/master/documentation/nixcloud.reverse-proxy.md
      user "reverse-proxy" "reverse-proxy";
      error_log stderr;

      daemon off;

      events {}
      http {
        server_names_hash_bucket_size 64;

        ${createServerRecords allProxyOptions allNCWDomains}
        ${cfg.extraConfig}
      }
    '';

    # walk through all `nixcloud.webservices` services, collect proxyOptions from enabled services
    # { house = { ... }; music = { ... }; test = { ... }; test1 = { ... }; }
    inherit (nclib) mapWSConfigToListCond;
    wsProxyOptions = mapWSConfigToListCond (x: x.enable) (x: x.proxyOptions);

    allProxyOptions = wsProxyOptions ++ cfg.extraMappings;

    # create a unique list of all domains from nixcloud.reverse-proxy
    allNCWDomains = unique (map (el: el.domain) allProxyOptions);

    #checks if any of the given extraLocations or websocketLocations has the given mode enabled.
    checkLocationMode = locations: mode: let
      hasModeEnabled = name: locations.${name}.${mode}.mode != "off";
    in lib.any hasModeEnabled (lib.attrNames locations);

    # a list of unique domains gained from nixcloud.webservices.proxyOption(s) which require a http server record in nginx.conf
    allHttpOnlyProxyOptions = filter (el: el.http.mode != "off" || checkLocationMode el.websockets "http" || checkLocationMode el.extraLocations "http") allProxyOptions;
    allHttpNCDomains = unique (map (el: el.domain) allHttpOnlyProxyOptions);

    # a complete list of domains using ACME simple list of ACME domains
    # since a domain might be a 'extraDomain' and the challanges folder is located via the identifier
    filterACME = filterAttrs (n: v: v.mode == "ACME");
    ACMEImpliedDomains =
      let
        allIdentifiers = attrNames (filterACME config.nixcloud.TLS.certs);
      in
        unique ((map (i: config.nixcloud.TLS.certs.${i}.domain) allIdentifiers) ++ fold (i: c: c ++ config.nixcloud.TLS.certs.${i}.extraDomains) [] allIdentifiers);






    # nixcloudTLSHandles
    #ProxyOptionsImpliedDomainsSet ...
    ACMEImpliedDomainsSet = (builtins.listToAttrs (
      let
        children = identifier: extraDomains: fold (domain: c: c ++ [ { name = "${domain}"; value = "/run/nixcloud/lego/${identifier}/challenges"; } ]) [] extraDomains;
      in
        fold (identifier: c: c ++ (children identifier config.nixcloud.TLS.certs.${identifier}.extraDomains)
          ++ [ { name = config.nixcloud.TLS.certs.${identifier}.domain; value = "/run/nixcloud/lego/${identifier}/challenges"; } ]) [] (attrNames (filterACME config.nixcloud.TLS.certs))));









    allHttpDomains = unique (ACMEImpliedDomains ++ allHttpNCDomains);

    # nixcloud.TLS details
    #   example value: { "lastlog.de" = "lastlog.de-identifier"; "nixcloud.io" = "nixcloud.io"; }
    #                  { domain (string) = nixcloud.TLS idenfier (string) };
    nixcloudTLSHandles = fold (el: c:
      if (c ? "${el.domain}") then
        let
          a=c.${el.domain};  # the saved nixcloud.TLS identifier
          b="${el.TLS}";     # the newly found nixcloud.TLS identifier for a different proxyOptions record
        in
          if (a == b) then
            c else abort "error: `${a}` != `${b}`! A conflict in `proxyOptions` for for domain ${el.domain}:${toString el.port}${el.path} with a record for the same domain added previously."
      else
        c // { "${el.domain}" = "${el.TLS}"; }
    ) {} allProxyOptions;

    createLocationRecords = mode: filteredProxyOptions:
      lib.concatMapStringsSep "\n" (location: (createLocationRecord mode location)) filteredProxyOptions;
    createLocationRecord = mode: location:
      let
        m = location.${mode}.mode;
        b = location.${mode}.basicAuth;
        r = location.${mode}.record;
        l = location.path;
        f = location.${mode}.flags;
        e = location.${mode}.extraFlags;
      in
        (if (m == "on") then
          ''
            ${location.${mode}.extraServerFlags}
            location ${l} {
              set $targetIP ${location.ip};
              set $targetPort ${toString location.port};
            ${if r == "" then ''
              ${f}
              ${e}
            '' else r
            }
              ${if (b != {}) then mkBasicAuth b else ""}
            }
          '' #"
        else if (m == "redirect_to_http" ) then 
          ''
            location ${l} {
              rewrite     ^   http://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "redirect_to_https" ) then
          ''
            location ${l} {
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "off") then ""
        else abort "unknown location mode: `${m}`, this should never happen.... but just in case!");

    #creates all extraLocation entries for the Reverse Proxy
    createExtraLocationsRecords = mode: filteredProxyOptions:
      lib.concatMapStringsSep "\n" (location: (createExtraLocationsRecords_ mode location)) filteredProxyOptions;
    #helper function that creates all extraLocation Reverse Proxy entries fo a single webservice
    createExtraLocationsRecords_ = mode: location:
      lib.concatMapStringsSep "\n" (w: createExtraLocationRecord mode location location.extraLocations.${w}) (attrNames location.extraLocations);
    createExtraLocationRecord = mode: location: extraLocation:
      let
        m = extraLocation.${mode}.mode;
        b = extraLocation.${mode}.basicAuth;
        r = extraLocation.${mode}.record;
        l = removeSuffix "/" (toString (builtins.toPath (location.path + extraLocation.subpath)));
        f = extraLocation.${mode}.flags;
        e = if extraLocation.${mode}.extraFlags == "" then location.${mode}.extraFlags else extraLocation.${mode}.extraFlags;
      in
        (if (m == "on") then
          ''
            location ${l} {
              set $targetIP ${extraLocation.ip};
              set $targetPort ${toString extraLocation.port};
            ${if r == "" then ''
              ${f}
              ${e}
            '' else r
            }
              ${if (b != {}) then mkBasicAuth b else ""}
            }
          '' #"
        else if (m == "redirect_to_http" ) then
          ''
            location ${l} {
              rewrite     ^   http://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "redirect_to_https" ) then
          ''
            location ${l} {
              rewrite     ^   https://$server_name$request_uri? permanent;
            }
          ''
        else if (m == "off") then ""
        else abort "unknown location mode: `${m}`, this should never happen.... but just in case!");


    #creates all Websocket entries for the Reverse Proxy
    createWsRecords = mode: filteredProxyOptions:
      lib.concatMapStringsSep "\n" (location: (createWsRecords_ mode location)) filteredProxyOptions;
    #helper function that creates all websocket Reverse Proxy entries fo a single webservice
    createWsRecords_ = mode: location:
      lib.concatMapStringsSep "\n" (w: createWsRecord mode location location.websockets.${w}) (attrNames location.websockets);

    #creates the reverseproxy entry for a single websocket Path
    createWsRecord = mode: location: websocket:
      let
        b = websocket.${mode}.basicAuth;
        r = websocket.${mode}.record;
        m = websocket.${mode}.mode;
        f = websocket.${mode}.flags;
        p = websocket.port;
        e = if websocket.${mode}.extraFlags == "" then location.${mode}.extraFlags else websocket.${mode}.extraFlags;
        ppp = removeSuffix "/" (toString (builtins.toPath (location.path + websocket.subpath)));
      in
        if (m == "on") then
          ''
            location ${ppp} {
              set $targetIP ${location.ip};
              set $targetPort ${toString p};
            ${if r == "" then ''
              ${f}
              ${e}
            '' else r
            }
              ${if (b != {}) then mkBasicAuth b else ""}
            }
          ''
        else if (m == "redirect_to_http") then ""
        else if (m == "redirect_to_https") then ""
        else if (m == "off") then ""       
        else abort "unknown location mode: `${m}`, this should never happen.... but just in case!";

    createServerRecords = allProxyOptions: allNCWDomains:
      concatMapStringsSep "\n" (x: x) (createHttpServerRecords allProxyOptions) +
      (concatMapStringsSep "\n" (createHttpsServerRecord allProxyOptions) allNCWDomains);

    # 3. map over these and create server (http/https) records per domain
    createHttpServerRecords = allProxyOptions: let
      createHttpServerRecord =  domain: let
        filteredProxyOptions = filter (e: e.domain == "${domain}") allProxyOptions;
      in
      ''
        server {
          listen ${toString cfg.httpPort};
          listen [::]:${toString cfg.httpPort};

          server_name ${domain};  
          ${optionalString (ACMEImpliedDomainsSet ? "${domain}")
          ''
            # ACME requires this in the http record (will not work over https)
            location /.well-known/acme-challenge {
              root ${ACMEImpliedDomainsSet."${domain}"};
              auth_basic off;
            }
          ''}

          ${createLocationRecords "http" filteredProxyOptions}
          ${createWsRecords "http" filteredProxyOptions}
          ${createExtraLocationsRecords "http" filteredProxyOptions}
        } ''; #"  '' ''

    in 
      (map createHttpServerRecord allHttpDomains);

    createHttpsServerRecord = allProxyOptions: domain:
    let
      filteredProxyOptions = filter (e: e.domain == "${domain}") allProxyOptions;
      needsHttps = any (el: el.https.mode != "off" || checkLocationMode el.websockets "https" || checkLocationMode el.extraLocations "https") filteredProxyOptions;
    in optionalString (filteredProxyOptions != [] && needsHttps) ''
      server {
        ssl on;
        listen ${toString cfg.httpsPort} ssl;
        listen [::]:${toString cfg.httpsPort} ssl;

        server_name ${domain};

        ssl_certificate ${config.nixcloud.TLS.certs.${nixcloudTLSHandles.${domain}}.tls_certificate};
        ssl_certificate_key ${config.nixcloud.TLS.certs.${nixcloudTLSHandles.${domain}}.tls_certificate_key};

        ${createLocationRecords "https" filteredProxyOptions}
        ${createWsRecords "https" filteredProxyOptions}
        ${createExtraLocationsRecords "https" filteredProxyOptions}
      }
    '';
    checkAndFormatNginxConfigfile = (import ../../web/webserver/lib/nginx_check_config.nix {inherit lib pkgs;}).checkAndFormatNginxConfigfile;
    configFile = generateNginxConfigFile allProxyOptions allNCWDomains;

  in mkIf (cfg.enable) {
    assertions = let
      getDomains = identifier: [ config.nixcloud.TLS.certs.${identifier}.domain ] ++ config.nixcloud.TLS.certs.${identifier}.extraDomains;
      # erroneousProxyOptions is a list of proxyOptions -> [ proxyOptions1 proxyOptions2 ... ] which have a erroneous configuration
      erroneousProxyOptions = filter (x: any (a: a != x.domain ) (getDomains x.TLS)) allProxyOptions;
      erroneousProxyOptionsString = fold (el: c: c + " * proxyOption = { domain=\"${el.domain}\"; path=\"${el.path}\"; port=\"${toString el.port}\"; TLS=\"${el.TLS}\"; };\n") "" erroneousProxyOptions;
    in [
      { assertion = erroneousProxyOptions == [];
        message = "Found erroneous 'proxyOption' record(s) with a proxyOptions.TLS identifier pointing to a nixcloud.TLS.certs.<identifier> where nixcloud.TLS.certs.<identifier>.domain is different to proxyOptions.domain:\n${erroneousProxyOptionsString}";
      }
    ];
    networking = {
      extraHosts = if cfg.extendEtcHosts then (concatMapStringsSep "\n" (x: "127.0.0.1 ${x}") allNCWDomains + "\n" + concatMapStringsSep "\n" (x: "::1 ${x}") allNCWDomains) else ""; 
      firewall = {
        allowedTCPPorts = [
          cfg.httpPort
          cfg.httpsPort
        ];
      };
    };
    systemd.services."nixcloud.reverse-proxy" = {
      description   = "Connects several webservers together and manages TLS and makes hosting easy!";

      wantedBy = [ "multi-user.target" ];
      after    = [ "nixcloud.TLS-reverse-proxy-certificates.target" ];
      wants    = [ "nixcloud.TLS-reverse-proxy-certificates.target" ];

      stopIfChanged = false;

      preStart = ''
        mkdir -p ${stateDir}/nginx/logs
        mkdir -p ${stateDir}/nginx
        chmod 700 ${stateDir}
        chown -R ${user}:${group} ${stateDir}
      '';
      serviceConfig = {
        ExecStart = "${pkgs.nginx}/bin/nginx -c ${if (cfg.configFile == null) then (checkAndFormatNginxConfigfile {inherit configFile; fileName = "nixcloud.reverse-proxy.conf";}) else cfg.configFile}/nixcloud.reverse-proxy.conf -p ${stateDir}/nginx";
        ExecReload = "${pkgs.coreutils}/bin/kill -HUP $MAINPID";
        Restart = "always";
        RestartSec = "10s";
        StartLimitInterval = "1min";
      };
    };


    users.extraUsers = (singleton
      { name = "${user}";
        group = "${group}";
      });

    users.extraGroups = (singleton
      { name = "${user}";
      });

    nixcloud.tests.wanted = [ ./test.nix ];
  };
}
